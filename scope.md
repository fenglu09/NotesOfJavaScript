[TOC]
<!-- TOC -->

- [作用域](#作用域)
    - [什么是作用域](#什么是作用域)
    - [作用域嵌套](#作用域嵌套)
    - [作用域查询规则](#作用域查询规则)
- [词法作用域](#词法作用域)
    - [什么时词法作用域](#什么时词法作用域)
    - [欺骗词法（运行时修改作用域）](#欺骗词法运行时修改作用域)
        - [eval](#eval)
        - [with](#with)
        - [性能](#性能)
- [变量提升](#变量提升)

<!-- /TOC -->
# 作用域
## 什么是作用域
作用域是根据名称查找变量的一套规则。用于确定在何处以及如何查找变量（标识符）。
如果查找的目的是对变量进行赋值，那么就会使用LHS 查询；如果目的是获取变量的值，就会使用RHS 查询。

## 作用域嵌套
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用
域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是全局作用域）为止。
例：
```js
function foo(a) {
    console.log( a + b );
}
var b = 2;
foo( 2 ); // 4
```
上面的代码中，对b的RHS引用无法在foo的作用域中完成，因此会查询外层作用域，即全局作用域。

## 作用域查询规则
作用域的查询主要有`RHS`和 `LHS`两种。
LHS 和RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。
作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

- 如果RHS查询在所有嵌套的作用域中(全局作用域)遍寻不到所需的变量，引擎就会抛出`ReferenceError`异常
- LHS查询，在所有嵌套的作用域中（全局作用域）无法找到目标变量，如果当前是非`严格模式`，则会在全局作用域中创建一个具有该名称的变量，并将其返还给引擎；如果当前模式不是严格模式，则会抛出`ReferenceError`异常。
- 如果RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用`null` 或`undefined` 类型的值中的属性，那么引擎会抛出`TypeError`异常.


JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像`var a = 2` 这样的声明会被分解成两个独立的步骤：
1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来，a = 2 会查询（LHS 查询）变量a 并对其进行赋值。


# 词法作用域
## 什么时词法作用域
词法作用域简单的讲，就是定义在词法阶段的作用域。词法作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段，基本能够知道全部标识符在哪里以及是如何声明的。

例：
```js
 // 全局作用域
function foo(a) {   // foo函数作用域
    var b = a * 2;
    function bar(c) {    // bar函数作用域
        console.log( a, b, c );
    }
    bar( b * 3 );
}
foo( 2 ); // 2, 4, 12
```
在这个例子中有三个逐级嵌套的作用域。

作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。。因此内部的标识符可以覆盖外部同名的标识符，这叫做“遮蔽效应”。
## 欺骗词法（运行时修改作用域）
JavaScript中有两种机制在运行时修改作用域：`eval(...)`和`with`;
### eval
该函数可以接受一个字符串为参数，并将其中的内容视为在书写时就存在于程序中的这个位置的代码。
* 原理

在写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。

在执行eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。
```js
function foo(str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```
`eval(..)` 调用中的`var b = 3;` 这段代码会被当作本来就在那里一样来处理。由于这段代码声明一个变量`a`，因此对本来这已经存在的`foo(...)`词法作用域进行了修改。

* 在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。
例如：
```js
function foo(str) {
    "use strict";
    eval( str );
    console.log( a ); // ReferenceError: a is not defined
}
foo( "var a = 2" );
```
* 其他类似功能：
JavaScript中还有一些功能效果和`eval(...)`很相似
    - `setTimeout()`和`setInterval()`的第一个参数可以是一个字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。
    - new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串

### with
with 通常被当作重复引用同一个对象中的多个属性的快捷方式。
例如：
```js
var obj = {
    a: 1,
    b: 2,
    c: 3
};
// 单调乏味的重复"obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}
```
但是这样也很容易导致一些问题。
```js
function foo(obj) {
    with (obj) {
        a = 2;
    }
}
var o1 = {
    a: 3
};
var o2 = {
    b: 3
};
foo( o1 );
console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```
上面的例子中，创建了两个对象o1和o2,其中o1包含一个属性a。`foo()`接收一个对象的引用作为参数，并对这个对象引用执行了`with(obj) {..}`。在width块的内部，看起来只是对变量a 进行简单的词法引用，实际上就是一个LHS 引用，并将2 赋值给它。
当我们将o1 传递进去，`a＝2` 赋值操作找到了`o1.a` 并将2 赋值给它，这在后面的`console.log(o1.a)` 中可以体现。而当o2 传递进去，o2 并没有a 属性，因此不会创建这个属性，`o2.a` 保持`undefined`。

尽管`with` 块可以将一个对象处理为词法作用域，但是这个块内部正常的`var`声明并不会被限制在这个块的作用域中，而是被添加到`with` 所处的函数作用域中。
例如：
```js
function foo(obj) {
    with(obj) {
        var a = 'in width block';
    }
    console.log(a);
}
foo({});  // in width block
```
上面的代码，虽然变量a在with代码块中定义，但是在with所属的函数foo中，仍然可以访问。

### 性能
`eval()` 和`with` 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。

JavaScript会在编译阶段进行数项性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但是如果使用了`eval(..)` 或`with`，引擎就无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的.

# 变量提升
变量提升指的是作用域中函数和变量的声明被提升到所在作用域的顶部。这是因为，编译器在代码编译阶段中的第一部分工作就是查找所有的声明，并用合适的作用域将它们关联起来。
```js
     console.log(a);   // undefined 而不是 ReferenceError
     var a = 2;
```
当我们看到`var a = 2;` 时，可能会觉得这是一个声明。但是JavaScript会把它当成`var a` 和 `a = 2`。第一个阶段`var a`在编译阶段进行，第二个赋值声明`a = 2`会被留在原地等待执行阶段。
因此上面的代码在执行的时候，`var a`变量的声明会被提升到顶部，上面的代码等价于下面的代码：
```js
    var a;
    console.log(a);
    a = 2;
```
- 每个作用域都会进行变量提升的操作。
- 变量提升时，会函数优先。先提升函数声明，然后在提升变量声明。
例如：
```js
    foo();  // 1
    var foo;
    function foo() {
        console.log('1');
    }
    foo = function() {
        console.log('2');
    }
```
上面的代码，打印出来的是1，而不是2；尽管，`var foo` 尽管出现在`function foo()...` 的声明之前,但是函数`foo`的声明首先被提前，所以变量`var foo`的声明是重复的，因此`var foo`声明会被忽略掉。
上面的代码等价于下面的代码：


